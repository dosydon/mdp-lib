#ifndef MDPLIB_PROBLEM_H
#define MDPLIB_PROBLEM_H

#include <list>
#include "state.h"
#include "action.h"
#include "util/rational.h"

/**
 * An abstract class for Stochastic Shortest Path Problem objects.
 */
class Problem
{
protected:
    /**
     * The initial state for the problem.
     */
    State* s0;

    /**
     * Discount factor.
     */
    Rational gamma_;

    /**
     * A list of all the possible actions in this problem.
     */
    std::list<Action *> actions_;

    /**
     * An internal structure to store all states that are generated by calls to the
     * transition function.
     */
    StateSet states_;

public:
    /**
     * Returns true if state s is a goal.
     */
    virtual bool goal(State *s) const =0;

    /**
     * Returns a list of all succcessors when action a is applied in state s.
     */
    virtual std::list<Successor> transition(State *s, Action *a) =0;

    /**
     * Returns the cost of applying action a in state s.
     */
    virtual Rational cost(State *s, Action *a) const =0;

    /**
     * Returns true if action a can be applied in state s.
     */
    virtual bool applicable(State *s, Action *a) const =0;

    /**
     * Returns the initial state for this problem.
     */
    virtual const State* initialState() const
    {
        return s0;
    }

    /**
    * Generates all states that can be reached from s0 and stores internally.
    */
    virtual void generateAll() { }

    /**
     * If a state equal to the given state has already been stored, it returns
     * the expanded state. Otherwise, it stores the state first and the returns it.
     */
    State *getState(State *s)
    {
        bool check = states_.insert(s).second;
        State *ret = *states_.find(s);
        // the void cast is used to check if the pointers point to the same object
        if ((void *) ret != (void *) s && !check)
            delete s;    // another state was already stored, get rid of the state used to find it
        return ret;
    }

    /**
     * Returns the set containing all states generated so far.
     */
    StateSet& states()
    {
        return states_;
    }

    /**
     * Returns the list of actions in this problem.
     */
    std::list<Action*>& actions()
    {
        return actions_;
    }

    /**
     * Returns the discount factor.
     */
    Rational gamma()
    {
        return gamma_;
    }
};

#endif // MDPLIB_PROBLEM_H
